{"version":3,"file":"scribe-plugin-noting.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../src/scribe-plugin-noting.js"],"sourcesContent":["define('scribe-plugin-noting',[],function () {\n\n  /*\n   * Plugin for adding a <note> elements around\n   * things.\n   */\n\n  'use strict';\n\n  return function (user) {\n    return function(scribe) {\n\n      //currently\n      var tag = \"span\";\n      var nodeName = \"SPAN\";\n      var className = \"note\";\n      var blocks = [\"P\", \"LI\", \"UL\"];\n\n      var noteCommand = new scribe.api.Command('insertHTML');\n\n\n      function createWrap() {\n        var wrap = document.createElement(tag);\n        wrap.className = className;\n        var date = new Date().getTime().toString();\n        wrap.setAttribute(\"data-edited\", user + \" \" + date);\n        return wrap;\n\n      }\n\n      function wrapText(content) {\n        //wrap the contents of a text node\n        // they behave diffent\n        var wrap = createWrap();\n        wrap.appendChild(content);\n        return wrap;\n      }\n\n      function wrapBlock(block) {\n        // for this one we need to get the text\n        // inside as the clone will wrap this in a p and\n        // we'll have to do more magic. So we append the\n        // wrap to the element inside the block\n        // there are some issues with LIs and Bs at the moment\n        var wrap = createWrap(wrap);\n        var temp = block.cloneNode(true);\n        wrap.innerHTML = temp.innerHTML;\n        temp.appendChild(wrap);\n        return temp;\n      }\n\n      function wrapRange(range, wrap) {\n        var temp = document.createDocumentFragment();\n        var childNodes = range.childNodes;\n\n        childNodes = Array.prototype.slice.call(childNodes);\n\n        childNodes.forEach(function (item) {\n          var tempNode;\n\n          if (!item) {\n            return;\n          }\n\n          if(item.nodeType === Node.TEXT_NODE) {\n            // this is for a basic selection\n            tempNode = wrapText(item, wrap);\n          } else {\n            tempNode = wrapBlock(item, wrap);\n          }\n\n          temp.appendChild(tempNode);\n        });\n\n        return temp;\n      }\n\n      function hasBlockElements (range) {\n        for (var i = 0, len = range.childNodes.length; i < len; i++) {\n          if(blocks.indexOf(range.childNodes[i].nodeName) !== -1) {\n            return true;\n          }\n          return false;\n        }\n      }\n\n      function checkScribeMarker (node) {\n        return (' ' + node.className + ' ').indexOf(' ' + \"scribe-marker\" + ' ') > -1;\n      }\n\n      function isNote (node) {\n        return (' ' + node.className + ' ').indexOf(' ' + \"note\" + ' ') > -1;\n      }\n\n      function findScribeMarker(node) {\n        if (checkScribeMarker(node)) {\n          // the passed node could also be the marker\n          return 1;\n        }\n\n        for(var i = 0, len = node.childNodes.length; i < len; i++) {\n          if(checkScribeMarker(node.childNodes[i])) {\n            return i;\n          }\n        }\n        return -1;\n      };\n\n\n\n      function walk(node, func) {\n        // this is a semi-recursive tree descent\n        // although it's a shame it uses a loop\n        // this could be trivially rewritten to be\n        // fully recursive\n        // this is far simpler than doing rubbish\n        // with do whiles\n        var children = node.childNodes;\n\n        for (var i = 0; i < children.length; i++) {\n          walk(children[i], func);\n        }\n\n        func(node);\n      }\n\n\n      function removeScribeMarkers (tree) {\n        walk(tree, function (node) {\n          if (checkScribeMarker(node)) {\n            node.parentElement.removeChild(node);\n          }\n        });\n      }\n\n      function unwrap (element) {\n        // get the innercontent and move it in place of the element\n        // TODO: Only does a basic unwrap - does not do the inner\n        // elements\n        var innerNode = element.firstChild;\n        var parent = element.parentNode;\n        parent.replaceChild(innerNode, element);\n      }\n\n      function getScribeMarker(arr) {\n        for (var i = 0, len = arr.length; i < len; i++) {\n          var el = arr[i];\n          if(checkScribeMarker(arr[i])) {\n            return i;\n          }\n        }\n        return -1;\n      }\n\n      function buildNodeList (tree, predicate) {\n        // walk a tree and build a list of nodes that need to be wrapped\n        var scribeMarkerLocated = false;\n        var done = false;\n        var nodeList = [];\n        walk(tree, function (node) {\n\n          if (done === true) {\n            return; //do nothing\n          }\n\n\n          if (checkScribeMarker(node)) {\n            // begin pushing elements\n            if (scribeMarkerLocated === true) {\n              done = true;\n            } else {\n              scribeMarkerLocated = true;\n            }\n          }\n\n          if (!done && scribeMarkerLocated && predicate(node)) {\n            //scribe markers do not get pushed\n            nodeList.push(node);\n          }\n\n        });\n        return nodeList;\n      }\n\n\n\n      /*\n       * This wraps all elements that contain block elements\n       * in a note class.\n       */\n      function wrapBlocks (selection, range) {\n\n        // drop markers so we can operate on all the sub elements in the selection\n        selection.placeMarkers();\n        selection.selectMarkers(true);\n\n        var commonAncestor = range.commonAncestorContainer;\n\n        var nodes = buildNodeList(commonAncestor, function (node) {\n          return !checkScribeMarker(node)\n            && (getScribeMarker(node.childNodes) === -1);\n        });\n\n\n        nodes.forEach(function (item, index, array) {\n          if (!item) {\n            return;\n          }\n\n          var wrap;\n          var parent = item.parentNode;\n          var sibling = item.nextSibling;\n\n          if (item.nodeType === Node.TEXT_NODE) {\n            // this is for a basic selection\n            wrap = wrapText(item);\n          } else {\n            wrap =  wrapBlock(item);\n          }\n\n          // replace directly on the tree\n          if (sibling) {\n            parent.insertBefore(wrap, sibling);\n          } else {\n            parent.appendChild(wrap);\n          }\n\n        });\n        selection.selectMarkers();\n      }\n\n\n      function iteratorWalk (commonAncestor, predicate) {\n        /*\n         * Basic algorithm\n         * Walk the DOM\n         * Find first scribe marker\n         * Wrap every element\n         * Find last scribe marker\n         * Return\n         */\n\n        var nodeIterator = document.createNodeIterator(commonAncestor, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);\n        var nodeList = [];\n        var done = false;\n        var scribeMarkerLocated = false;\n\n\n\n\n        var node = nodeIterator.nextNode(); //skip the first element\n        while (node = nodeIterator.nextNode()) {\n          // when the count is 0 return\n\n          if (done === true) {\n            return; //do nothing\n          }\n\n          if (checkScribeMarker(node)) {\n            // begin pushing elements\n            if (scribeMarkerLocated === true) {\n              done = true;\n            } else {\n              scribeMarkerLocated = true;\n            }\n          }\n\n          if (!done && scribeMarkerLocated && predicate(node)) {\n            //scribe markers do not get pushed\n            nodeList.push(node);\n          }\n        }\n        return nodeList;\n      }\n\n      noteCommand.execute = function () {\n\n        var selection = new scribe.api.Selection();\n        var range = selection.range;\n        var commonAncestor;\n\n        // if the selection is the whole line, then we need to note the whole line\n        // if it isn't then we just do the bit selected and nothing else.\n        // selection.selection.data currently will duplicate things if there is no\n        // actual selection\n        if(selection.selection.type === \"Range\") {\n\n          if (this.queryState()) {\n\n            if (!hasBlockElements(range.cloneContents())) {\n              // this is a seriously flaky way of doing it at the moment\n              // I think there are much better alternatives\n              // TODO: Investigate if it's even worth doing this on an undo\n              // might just be able to use unwrap in the same way as it works\n              // when there are block elements.\n\n\n              // drop markers to play with the sibling\n              selection.placeMarkers();\n              selection.selectMarkers(true);\n\n              commonAncestor = range.commonAncestorContainer;\n              var parent = commonAncestor.parentNode;\n\n              // this is random - but basically the range thinks the\n              // span is the common ancestor if we only select a little bit of\n              // the note\n              if (commonAncestor.nextSibling) {\n                parent = commonAncestor.nextSibling.parentNode;\n              } else if (commonAncestor.previousSibling) {\n                parent = commonAncestor.previousSibling.parentNode;\n              }\n\n\n              var contents = document.createTextNode(commonAncestor.innerText);\n              parent.replaceChild(contents, commonAncestor);\n              selection.selectMarkers();\n\n            } else {\n              // remove all styling from elements within the range\n              // in this case they have selected multiple nodes\n              selection.placeMarkers();\n              selection.selectMarkers(true);\n\n              // do a recursive unwrap\n              commonAncestor = range.commonAncestorContainer;\n              var toBeUnWrapped = buildNodeList(commonAncestor, function (node) {\n                return isNote(node);\n              });\n\n              toBeUnWrapped = Array.prototype.slice.call(toBeUnWrapped);\n\n              toBeUnWrapped.forEach(function (item) {\n                unwrap(item);\n              });\n\n              selection.selectMarkers();\n            }\n\n\n          } else {\n            // check if the selection has block elements.\n            // if it does do the complex version,\n            // otherwise do the simple version\n            if (!hasBlockElements(range.cloneContents())) {\n              var wrapped = wrapRange(range.cloneContents());\n              range.deleteContents();\n              range.insertNode(wrapped);\n            } else {\n              wrapBlocks(selection, range);\n            }\n          }\n        }\n\n      };\n\n      noteCommand.queryState = function () {\n        // TODO: The instance in which there are more scribe nodes\n        // clone the range and see if there are spans in it\n        var selection = new scribe.api.Selection();\n        var scribeEls = selection.range.cloneContents().querySelectorAll('.note');\n        var containsNote = function (scribeEls) {\n          for (var i = 0, len = scribeEls.length; i < len; i++) {\n            if (isNote(scribeEls[i])) {\n              return true;\n            }\n          }\n        };\n\n        // check if there is a note in the selection\n        var isNode = !!selection.getContaining(function (node) {\n          return isNote(node);\n        });\n\n        return isNode || containsNote(scribeEls);\n\n      };\n\n\n      noteCommand.queryEnabled = function () {\n        var selection = new scribe.api.Selection();\n        var headingNode = selection.getContaining(function (node) {\n          return (/^(H[1-6])$/).test(node.nodeName);\n        });\n\n        return scribe.api.CommandPatch.prototype.queryEnabled.apply(this, arguments) && ! headingNode;\n      };\n\n\n      scribe.commands.note = noteCommand;\n\n      /* There may be case when we don't want to use the default commands */\n\n      scribe.el.addEventListener('keydown', function (event) {\n        //that's F10\n        if (event.keyCode === 121) {\n          var noteCommand = scribe.getCommand(\"note\");\n          var selection = new scribe.api.Selection();\n          var range = selection.range;\n\n          noteCommand.execute();\n        }\n      });\n    };\n  };\n});\n\n"],"names":[]}