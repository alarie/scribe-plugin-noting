{"version":3,"file":"scribe-plugin-noting.min.js","mappings":"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","sources":["../src/scribe-plugin-noting.js"],"sourcesContent":["define('scribe-plugin-noting',[],function () {\n\n  /*\n   * Plugin for adding a <note> elements around\n   * things.\n   */\n\n  'use strict';\n\n  return function (user) {\n    return function(scribe) {\n\n      //currently\n      var tag = \"gu:note\";\n      var nodeName = \"GU:NOTE\";\n      var className = \"note\";\n      var dataName = \"data-edited-by\";\n      var dataDate = \"data-edited-date\";\n      var blocks = [\"P\", \"LI\", \"UL\"];\n\n      var noteCommand = new scribe.api.Command('insertHTML');\n\n\n      function createWrap() {\n        var wrap = document.createElement(tag);\n        wrap.className = className;\n        var date = new Date().getTime().toString();\n        wrap.setAttribute(\"data-edited-by\", user);\n        wrap.setAttribute(\"data-edited-date\", date);\n        return wrap;\n\n      }\n\n      function wrapText(content) {\n        //wrap the contents of a text node\n        // they behave diffent\n        var wrap = createWrap();\n        wrap.appendChild(content);\n        return wrap;\n      }\n\n      function wrapBlock(block) {\n        // for this one we need to get the text\n        // inside as the clone will wrap this in a p and\n        // we'll have to do more magic. So we append the\n        // wrap to the element inside the block\n        // there are some issues with LIs and Bs at the moment\n        var wrap = createWrap();\n        var temp = block.cloneNode(true);\n        wrap.innerHTML = temp.innerHTML;\n        temp.appendChild(wrap);\n        return temp;\n      }\n\n      function wrapRange(range) {\n        var temp = document.createDocumentFragment();\n        var childNodes = range.childNodes;\n\n        childNodes = Array.prototype.slice.call(childNodes);\n\n        childNodes.forEach(function (item) {\n          var tempNode;\n\n          if(item.nodeType === Node.TEXT_NODE) {\n            // this is for a basic selection\n            tempNode = wrapText(item);\n          } else {\n            tempNode = wrapBlock(item);\n          }\n\n          temp.appendChild(tempNode);\n        });\n\n        return temp;\n      }\n\n      function hasBlockElements (range) {\n        var childNodes = range.childNodes;\n\n        childNodes = Array.prototype.slice.call(childNodes);\n\n        var temp = childNodes.filter(function (item) {\n          return blocks.indexOf(item.nodeName) !== -1;\n        });\n\n        return temp.length > 0;\n      }\n\n      function checkScribeMarker (node) {\n         return checkClass(node, \"scribe-marker\");\n      }\n\n      function checkClass(node, value) {\n        if (!node.classList) {\n          return false;\n        }\n        return node.classList.contains(value);\n      }\n\n\n      function isNote (node) {\n        return node.tagName === nodeName;\n      }\n\n      function findScribeMarker(node) {\n        if (checkScribeMarker(node)) {\n          // the passed node could also be the marker\n          return 1;\n        }\n\n        for(var i = 0, len = node.childNodes.length; i < len; i++) {\n          if(checkScribeMarker(node.childNodes[i])) {\n            return i;\n          }\n        }\n        return -1;\n      };\n\n\n\n      function walk(node, func) {\n        // this is a semi-recursive tree descent\n        // although it's a shame it uses a loop\n        // this could be trivially rewritten to be\n        // fully recursive\n        // this is far simpler than doing rubbish\n        // with do whiles\n        var children = node.childNodes;\n\n        for (var i = 0; i < children.length; i++) {\n          walk(children[i], func);\n        }\n\n        func(node);\n      }\n\n      function unwrap (element) {\n        // get the innercontent and move it in place of the element\n        // TODO: Only does a basic unwrap - does not do the inner\n        // elements\n        var innerNode = element.firstChild;\n        var parent = element.parentNode;\n        parent.replaceChild(innerNode, element);\n      }\n\n      function getScribeMarker(arr) {\n        for (var i = 0, len = arr.length; i < len; i++) {\n          var el = arr[i];\n          if(checkScribeMarker(arr[i])) {\n            return i;\n          }\n        }\n        return -1;\n      }\n\n      function buildNodeList (tree, predicate) {\n        // walk a tree and build a list of nodes that need to be wrapped\n        var scribeMarkerLocated = false;\n        var done = false;\n        var nodeList = [];\n        walk(tree, function (node) {\n\n          if (done) {\n            return; //do nothing\n          }\n\n\n          if (checkScribeMarker(node)) {\n            // begin pushing elements\n            if (scribeMarkerLocated === true) {\n              done = true;\n            } else {\n              scribeMarkerLocated = true;\n            }\n          }\n\n          if (!done && scribeMarkerLocated && predicate(node)) {\n            //scribe markers do not get pushed\n            nodeList.push(node);\n          }\n\n        });\n        return nodeList;\n      }\n\n\n\n      /*\n       * This wraps all elements that contain block elements\n       * in a note class.\n       */\n      function wrapBlocks (selection, range) {\n\n        // drop markers so we can operate on all the sub elements in the selection\n        selection.placeMarkers();\n        selection.selectMarkers(true);\n\n        var commonAncestor = range.commonAncestorContainer;\n\n        var nodes = buildNodeList(commonAncestor, function (node) {\n          return !checkScribeMarker(node)\n            && (getScribeMarker(node.childNodes) === -1);\n        });\n\n\n        nodes.forEach(function (item, index, array) {\n          var wrap;\n          var parent = item.parentNode;\n          var sibling = item.nextSibling;\n\n          if (item.nodeType === Node.TEXT_NODE) {\n            // this is for a basic selection\n            wrap = wrapText(item);\n          } else {\n            wrap =  wrapBlock(item);\n          }\n\n          // replace directly on the tree\n          if (sibling) {\n            parent.insertBefore(wrap, sibling);\n          } else {\n            parent.appendChild(wrap);\n          }\n\n        });\n        selection.selectMarkers();\n      }\n\n      function basicUnwrap(selection, range) {\n        // this is a seriously flaky way of doing it at the moment\n        // I think there are much better alternatives\n        // TODO: Investigate if it's even worth doing this on an undo\n        // might just be able to use unwrap in the same way as it works\n        // when there are block elements.\n\n\n        // drop markers to play with the sibling\n        selection.placeMarkers();\n        selection.selectMarkers(true);\n\n        var commonAncestor = range.commonAncestorContainer;\n        var parent = commonAncestor.parentNode;\n\n        // this is random - but basically the range thinks the\n        // span is the common ancestor if we only select a little bit of\n        // the note\n        if (commonAncestor.nextSibling) {\n          parent = commonAncestor.nextSibling.parentNode;\n        } else if (commonAncestor.previousSibling) {\n          parent = commonAncestor.previousSibling.parentNode;\n        }\n\n\n        var contents = document.createTextNode(commonAncestor.innerText);\n        parent.replaceChild(contents, commonAncestor);\n        selection.selectMarkers();\n\n\n      }\n\n\n      function descentUnwrap (selection, range) {\n        // remove all styling from elements within the range\n        // in this case they have selected multiple nodes\n        selection.placeMarkers();\n        selection.selectMarkers(true);\n\n        // do a recursive unwrap\n        var commonAncestor = range.commonAncestorContainer;\n        var toBeUnWrapped = buildNodeList(commonAncestor, function (node) {\n          return isNote(node);\n        });\n\n        toBeUnWrapped = Array.prototype.slice.call(toBeUnWrapped);\n\n        toBeUnWrapped.forEach(function (item) {\n          unwrap(item);\n        });\n\n        selection.selectMarkers();\n\n      }\n\n\n      noteCommand.execute = function () {\n\n        var selection = new scribe.api.Selection();\n        var range = selection.range;\n        var cloned = range.cloneContents();\n        // if the selection is the whole line, then we need to note the whole line\n        // if it isn't then we just do the bit selected and nothing else.\n        // selection.selection.data currently will duplicate things if there is no\n        // actual selection\n        if(selection.selection.type === \"Range\") {\n\n          if (this.queryState()) {\n\n            if (!hasBlockElements(cloned)) {\n              basicUnwrap(selection, range);\n            } else {\n              descentUnwrap(selection, range);\n            }\n          } else {\n            // check if the selection has block elements.\n            // if it does do the complex version,\n            // otherwise do the simple version\n            if (!hasBlockElements(cloned)) {\n              var wrapped = wrapRange(cloned);\n              range.deleteContents();\n              range.insertNode(wrapped);\n            } else {\n              wrapBlocks(selection, range);\n            }\n          }\n        }\n\n      };\n\n      noteCommand.queryState = function () {\n        // TODO: The instance in which there are more scribe nodes\n        // clone the range and see if there are spans in it\n        var selection = new scribe.api.Selection();\n        var scribeEls = selection.range.cloneContents().querySelectorAll('.note');\n        var containsNote = function (scribeEls) {\n          for (var i = 0, len = scribeEls.length; i < len; i++) {\n            if (isNote(scribeEls[i])) {\n              return true;\n            }\n          }\n        };\n\n        // check if there is a note in the selection\n        var isNode = !!selection.getContaining(function (node) {\n          return isNote(node);\n        });\n\n        return isNode || containsNote(scribeEls);\n\n      };\n\n      scribe.commands.note = noteCommand;\n\n      /* There may be case when we don't want to use the default commands */\n\n      scribe.el.addEventListener('keydown', function (event) {\n        //that's F10 and F8\n        if (event.keyCode === 121 ||event.keyCode === 119) {\n          var noteCommand = scribe.getCommand(\"note\");\n          noteCommand.execute();\n        }\n      });\n    };\n  };\n});\n\n"],"names":[]}